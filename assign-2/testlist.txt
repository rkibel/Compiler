Id:
- Valid: Id(x)
- Invalid: Id(2)--works but won't with type checking

Num:
- Valid: Num(3)
- Invalid: Num(3.0), Num(a)-catches a check

Unop:
- Valid: Star Id(x),  Dash Id(x)
- Invalid: Id(x) Dash, Star Num(2), -Struct (all fail)
- Multiple: 
    - Valid: Star Dash Id(x) (works)

Binop
- Valid: Id(x) Dash/Plus Id(y)
- Id(x) Star Id(y)
-  OpenParen Id(x) Plus Id(y) CloseParen Star Id(y)
-Invalid: Id(x) Dash Plus Id(y) - correctly fails

Binop and Unop
- Valid
- Id(x) Dash Star Id(y) - yes
- Id(x) Dash Star Id(y) - yes
- Star OpenParen Dash Id(x) Plus Id(x) OpenBracket Star Id(x) CloseBracket CloseParen OpenBracket Num(2) Dash Id(x) CloseBracket

Access:
- Valid: Id(x) OpenBracket Num(1) CloseBracket
- Invalid: Num(a) no, Id(2) yes
    - Id(x) OpenBracket Id(1) CloseBracket - passes, typez
-Multiple: 
1.  Id(x)   //Works
    OpenBracket
    Num(1)
    CloseBracket
    OpenBracket
    Num(2)
    CloseBracket
    OpenBracket
    Num(3)
    CloseBracket
2. Two Star's infront of 1. works


Several:
x+*y-(z[1]*2); //Success
Id(x)
Plus
Star
Id(y)
Dash
OpenParen
Id(z)
OpenBracket
Num(1)
CloseBracket
Star
Num(2)
CloseParen
Semicolon


Duplicate names:
#1
let x:int, x:int, x:int;
struct y{a:int, a:int}
fn main() -> int {
return 0;
}

This works. So we just store one but it's not an error.

#2: Nil type errors in main and other function
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + nil;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + nil;
return 0;
}


#2: Function calling another function
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    g(x);
    h(x);
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + 2;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + y;
return z;
}

#3: Type errors are ordered alphabetically
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y;
    return nil + z[1];
}
fn main() -> int {
return 0;
}

#Which type to return? Not always Any.

struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y + z;
    let b:int = z;
    return f();
}
fn main() -> int {
return;
}

//return f() causes an error: in function g: should return nothing but returning int, 
//replacing f() with nil + z[1], or any addition, also gives the int error
//nil gives &_, z gives _. Clearly, for non nil or variable, you should return what it intends to

#4: Deref error returns Any
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    let r:int;
    return *r;
}
fn main() -> int {
return;
}

#4: Dereferncing nil works as many times, becuase it becomes any. NOTE, actual grammar must return
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn e(eval:int) -> int { 
    return eval;
}
fn f(fval:int) -> int { 
    return ******nil;
}
fn main() -> int {
    return;
}


Binop:
#1: left error then right error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + ex;
}

#2 Binop eq/not eq order: left right, both types different
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (ex == ex2);
    return 1;
}

#3: Binop with Any type compares equal correctly (only one error)
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (z == ex2);
    return 1;
}

#ArrayAccess

#1: Don't need to worry about nil, parse error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int = nil[1]; (also x = nil.x doesn't work)
    return 1;
}

#2: Order, int type first
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int, x:int, y:int, ex:s;
    n = new int;
    x = y[ex];
    return 2;
}

Structs:
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + s;
}

#2: Global var as struct
struct s{a:int}
let g:s;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    g = 5;
    return 2;
}

#3: his example:

struct list {
  value: int,
next: &list }
fn main() -> int {
  let n:&list, m:&list, i:int = 3;
  n = new list;
  m = n;
  while i > 0 {
    n.next = new list;
    n.value = i;
    n = n.next;
    i = i - 1;
}
  return aggregate(m);
}
fn aggregate(p: &list) -> int {
  let m:&list, i:int = 0;
  while m != nil {
    i = 10 * i + m.value;
m = m.next; }
return i; }

#4: Struct accesses must be from pointers
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int, st:t;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    z = st.q;
    return 2;
}

#5 Don't need to worry about nillet g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int;
    x = nil.x
    return 1;
}

Miscellaneous:
#1: Main has to have local variable declaraions at top
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int;
    let x:int = 2;
    n = new int;
    let x:int;
    return 2;
}

#2: Errors sorted by alphabetical value for key and error list!
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    return 2;
}
