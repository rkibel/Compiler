Id:
- Valid: Id(x)
- Invalid: Id(2)--works but won't with type checking

Num:
- Valid: Num(3)
- Invalid: Num(3.0), Num(a)-catches a check

Unop:
- Valid: Star Id(x),  Dash Id(x)
- Invalid: Id(x) Dash, Star Num(2), -Struct (all fail)
- Multiple: 
    - Valid: Star Dash Id(x) (works)

Binop
- Valid: Id(x) Dash/Plus Id(y)
- Id(x) Star Id(y)
-  OpenParen Id(x) Plus Id(y) CloseParen Star Id(y)
-Invalid: Id(x) Dash Plus Id(y) - correctly fails

Binop and Unop
- Valid
- Id(x) Dash Star Id(y) - yes
- Id(x) Dash Star Id(y) - yes
- Star OpenParen Dash Id(x) Plus Id(x) OpenBracket Star Id(x) CloseBracket CloseParen OpenBracket Num(2) Dash Id(x) CloseBracket

Access:
- Valid: Id(x) OpenBracket Num(1) CloseBracket
- Invalid: Num(a) no, Id(2) yes
    - Id(x) OpenBracket Id(1) CloseBracket - passes, typez
-Multiple: 
1.  Id(x)   //Works
    OpenBracket
    Num(1)
    CloseBracket
    OpenBracket
    Num(2)
    CloseBracket
    OpenBracket
    Num(3)
    CloseBracket
2. Two Star's infront of 1. works


Several:
x+*y-(z[1]*2); //Success
Id(x)
Plus
Star
Id(y)
Dash
OpenParen
Id(z)
OpenBracket
Num(1)
CloseBracket
Star
Num(2)
CloseParen
Semicolon


Duplicate names:
#1
let x:int, x:int, x:int;
struct y{a:int, a:int}
fn main() -> int {
return 0;
}

This works. So we just store one but it's not an error.

#2: Nil type errors in main and other function. Note: let statements allowed successive lines.
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + nil;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + nil;
return 0;
}


#2: Function calling another function
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    g(x);
    h(x);
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + 2;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + y;
return z;
}

#3: Type errors are ordered alphabetically
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y;
    return nil + z[1];
}
fn main() -> int {
return 0;
}

#Which type to return? Not always Any.

struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y + z;
    let b:int = z;
    return f();
}
fn main() -> int {
return;
}

//return f() causes an error: in function g: should return nothing but returning int, 
//replacing f() with nil + z[1], or any addition, also gives the int error
//nil gives &_, z gives _. Clearly, for non nil or variable, you should return what it intends to

#4: Deref error returns Any
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    let r:int;
    return *r;
}
fn main() -> int {
return;
}

#4: Dereferncing nil works as many times, becuase it becomes any. NOTE, actual grammar must return
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn e(eval:int) -> int { 
    return eval;
}
fn f(fval:int) -> int { 
    return ******nil;
}
fn main() -> int {
    return;
}


Binop:
#1: left error then right error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + ex;
}

#2 Binop eq/not eq order: left right, both types different
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (ex == ex2);
    return 1;
}

#3: Binop with Any type compares equal correctly (only one error)
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (z == ex2);
    return 1;
}

#ArrayAccess

#1: Don't need to worry about nil, parse error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int = nil[1]; (also x = nil.x doesn't work)
    return 1;
}

#2: Order, int type first
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int, x:int, y:int, ex:s;
    n = new int;
    x = y[ex];
    return 2;
}

Structs:
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + s;
}

#2: Global var as struct
struct s{a:int}
let g:s;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    g = 5;
    return 2;
}

#3: his example:

struct list {
  value: int,
next: &list }
fn main() -> int {
  let n:&list, m:&list, i:int = 3;
  n = new list;
  m = n;
  while i > 0 {
    n.next = new list;
    n.value = i;
    n = n.next;
    i = i - 1;
}
  return aggregate(m);
}
fn aggregate(p: &list) -> int {
  let m:&list, i:int = 0;
  while m != nil {
    i = 10 * i + m.value;
m = m.next; }
return i; }

#4: Struct accesses must be from pointers
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int, st:t;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    z = st.q;
    return 2;
}

#5 Don't need to worry about nillet g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int;
    x = nil.x
    return 1;
}

#6 Shows the types of local structs and outer structs. If you print all structs and locals after making maps
struct t{a:int}
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn main() -> int {
    let tex:&t, x:int;
    return;
}
Structs
t:
Key:[a] Value:[int]

Locals
f:
Key:[x] Value:[int]
Key:[tex] Value:[&struct_t]
Key:[fval] Value:[int]
Key:[f] Value:[&(int) -> int]


#7 Non-existent struct type:

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:&q;
    x = new q;
    return x.a;
}

#9 Incorrect type
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:s;
    return x.a;
}

#10 Any type with more than one preceding & is incorrect
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:&&t;
    x = new q;
    return x.a;
}

Functions:
#1: Can call main (with error) and still get parameter number comparisons. Replacing with main() works. Main calls can't be external. Main overwrites.
struct t{a:int}
extern main:(int, int) -> int;
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> _ {
    let x:int;
    x = main(2, 3);
}
fn main() -> int {
    let x:int;
    x = main(2, 3);
    g();
    return *x + -nil;
}

#2 nil() is a parse error

#3 can't have empty arguments f(2,)

#4 Example using Functions: can't have function or struct types as argument (CAN HAVE FUNCTION POINTERS) Error that ext has struct or function type
struct t{a:int}
extern e:(int) -> int;
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn g(r:int) -> int {
    return 3;
}
fn main() -> int {
    let x:int;
    x = f(2, e, g);
    return 1;
}

#5: CAN return an extern
struct t{a:int}
extern e:(int) -> int;
fn f() -> _ {}
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn temp(t:int) -> int {
    return 1;
}
fn g(r:int) -> (int)->int {
    return e;
}
fn main() -> int {
    let x:int;
    return 1;
}

#6 Functions take precedence over duplicate extern names

struct t{a:int}

fn e(x:int) -> int {
    return 1;
}
extern e:(int) -> int;
fn f() -> _ {}
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn temp(t:int) -> int {
    return 1;
}
fn g(r:int) -> (int)->int {
    return e;
}
fn main() -> int {
    let x:int;
    return 1;
}

#7 Calling main gives callee with type Id(main)
struct t{a:int}

fn e(x:int) -> int {
    return 1;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int = main();
    return 1;
}

#8 Number of parameters don't match and parameters types. This way, both a number error and type mismatching. If you swap x and y then parameters do match but not equal number.
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int;
    x = g(2);
    return 1;
}

#9 Error messages for all incorrect types
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int, y:t;
    x = g(2, y, 3);
    return 1;
}

#10 Confirming that expression type must equal parameter type
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int, y:t, z:int;
    x = g(x+z);
    return 1;
}

#11 Last main matters
struct t{a:int}
extern main:(int, int) -> int;
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> _ {
    let x:int;
    return;
}
fn main() -> int {
    let x:int;
    return main(2, 3);
}
fn main(x:int) -> _ {
    return;
}

#12 undefined still gives main error
struct t{a:int}
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> int {
    let x:int;
    return main(1, 2);
}


#13 Function pointers
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int, t) -> _;
fn main() -> int {
    let x:int, y:s, z:&(int)->int;
    *z(1);
    return;
}

#14 Main doesn't propagate

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int, t) -> _;
fn main() -> int {
    let x:int, y:s, z:main;
    z(1);
    return;
}


#15 Main defined as extern doesn't count as extern, as intern
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let x:int, y:s;
    main(1);
    k(1);
    return;
}

#16 Function pointer need to handle

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let x:int, y:()->_;
    y = 2;
    y(1);
    return;
}

#17 Global function pointers also work, but overriden by things like locals (if you replace z with x in h())
let x:&(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let z:int, y:()->_;
    y = 2;
    x(1);
    return;
}

#18 Parameters still need to match for extern
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int) -> int {
    main(1);
    return 2;
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return z.b;
}

#19 Good example, main a parameter
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int, z:()->_) -> int {
    main(1);
    z(1);
    return 2;
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return z.b;
}

#20: Huge example. Works. Also works if f replaced for f() as argument
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int, z:(int)->int) -> int {
    main(1);
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return g(1, 2, f);
}

#21 Testing local variable overriding non main function (works, also works with replace f in g() param for x or e)

let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(f:int, y:int, z:(int)->int) -> int {
    f();
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return g(1, 2, f(1));
}


Miscellaneous:
#1: Main has to have local variable declaraions at top
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int;
    let x:int = 2;
    n = new int;
    let x:int;
    return 2;
}

#2: Errors sorted by alphabetical value for key and error list!
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    return 2;
}

Guards:

#1 Don't need to update gamma
let x:(int)->int, y:&t;
struct t{a:int}
struct s{a:int}
fn f(x:int) -> &s {
    return;
}
fn g(x:int, fun:f) -> int {
    let x:&t, y:int;
    y = 3;
    if x {
        y = 2;
    }
    return x.a;
}





Global/struct/function:

#1 Declaring global as struct (parse_ref errors if remove &, global struct or function type)
let x:(int)->int, y:&t;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(e:int, y:int, z:(int)->int) -> int {
    e();
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    y.a = 2;
    x();
    return g(1, 2, f(1));
}

#2 Function variables should check parameters AND locals. Don't have locals override yet.
let x:(int)->int, y:&t;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(fun:f) -> int {
    let fun:int;
    fun(2);
    return 2;
}

#3. Note, we showed earlier that errored types still get treated even if they error in struct/global.

#4 Incorrect initialization type
let x:(int)->int, y:&t;
struct t{a:int}
struct s{a:int}
fn f(x:int) -> &s {
    return;
}
fn g(x:int, fun:f) -> int {
    let x:int = f();
    
    return 2;
}


#5 Large function test
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(f:int, y:int, z:(int)->int) -> int {
    f();
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let g:(int)->int = f;
    return g(1, 2, f(1));
}


Current?
let x:(int)->int, y:t;
struct t{a:int}
struct s{a:int}
fn f(x:int) -> &s {
    return;
}
fn g(x:int, fun:f) -> int {
    let x:&q, y:int, z:int;
    if x==1 {
        z = x+y;
    }
    return z;
}






TEST CASES:

let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(f:int, y:int, z:(int)->int) -> int {
    f();
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let g:(int)->int = wow;
    return g(1, 2, f(1));
}


struct s{a:&int, b:&int}
extern e:(int, int) -> int;
extern main:()->int;
fn f(fval:int) -> int { 
    return q; 
}
fn main() -> int {
    let id1:int, id2:&int, id3:&int, f1:(int, &int) -> int;
    f = id2;
    return 1;
}

#3 Important! Functions from struct parameters. Probably need their own function map since they are separate.
struct list {
  fun : &(int)->int,
  fun:int
}
let fun:&(int, int)->_;


fn main() -> int {
    let s:&list, x:int;
    s = new list;
    fun(1,1);
    s.fun(1);
    return 1;
}

#4 Fails pretty bad on this one:

truct list1 {
  fun : &(int)->int
}
struct list2 {
  fun : &(int)->int,
  st : list1
}
let fun:&(int, int)->_;

fn main() -> int {
    let s:&list2, x:int;
    s = new list2;
    x = s.st.fun(1);
    return 1;
}

#5 Almost to 6, but this shows you can't access struct type of another struct
struct list1 {
  fun : &(int)->int
}
struct list2 {
  fun : &(int,int)->int,
  st : list1
}
let fun:&(int, int)->_;

fn main() -> int {
    let s:&list2, t:&list1;
    t.fun();
    s.st.fun();
    return 0;
}

#6 Big: Each struct knows it's Functions. If fun in list one removed & to be a function type no pointer, it gives an error but still works.
struct list1 {
  fun : &(int)->int
}
struct list2 {
  fun : &(int,int)->int,
  st : &list1
}
let fun:&(int, int)->_;

fn main() -> int {
    let s:&list2, t:&list1;
    t.fun();
    s.fun();
    s.st.fun();
    return 0;
}

#7 Don't include structs in gamma
struct list1 {
  fun : (int)->int
}
struct list2 {
  fun : &(int,int)->int,
  st : &list1
}
struct main {a:int}
let fun:&(int, int)->_;

fn main() -> int {
    main();
    list1();
    list3();
    return 0;
}

#8 Field access still for struct function calls
struct list1 {
  fun : &&&&&&(int)->_
}
fn main() -> int {
    let t:&list1;
    t.fun();
    return 0;
}

#9 Confirming main can be overuled as parameter
struct list1 {
  fun : &&(int)->_,
  x:int
}
fn h(main:int) -> int {
  main();
}
fn main() -> int {
    let t:&list1, s:&&list1, y:int;
    y = s.x;
    t.fun();
    return 0;
}

#10
struct list1 {
  fun : &&(int)->_,
  x:int
}
fn main() -> int {
    let t:&list1, s:&list1, y:int;
    y = s.fun();
    return 0;
}

#11 Problem, not exactly a field access?

#12 Works now

struct list1 {
  fun : &(int)->_,
  gun :int,
  x:int
}
fn main() -> int {
    let id5:&&()->int = id5, id4:int;
    while id5[id4]() {
      *id5();
    }
  return 0;
}



#Issue 
struct list1 {
  fun : &(int)->int,
  x:int
}
struct list2 {
  s: &list1
}
fn main() -> int {
    let id5:&&()->&list2;
    while id5[id4]().s.fun(2) {
    }
  return 0;
}


No double callstruct //parse error
list1 { 
  fun : &(int)->int,
  x:int
}
struct list2 {
  s: &list1
}
fn main() -> int {
    let id5:&&()->&()->int;
    id5[1]()();
    return 0;
}


#Seg fault

struct list1 {
  fun : &(int)->int,
  x:int
}
struct list2 {
  s: &list1
}
fn main() -> int {
    let id5:&&()->&list2;
    while id5[id4]().s.fun(2) {
    }
  return 0;
}

#Works!
struct list1 {
  main : &(int)->int,
  x:int
}
struct list2 {
  s: &list1
}
fn main() -> int {
    let id5:&&()->&list2, id4:int;
    while id5[id4](2, 3).s.main(2) {
    }
  return 0;
}


#Works
fn main() -> int {
  let id6:(int)->int, id7:&int, id8:r, id9:&(int)->int;
  *i9 = id6; 
  return id9;
}

#Assignment struct or function type
fn main() -> int {
  let id6:(int)->int, id7:&int;
  id6 = id7;
  return id9;
}


What's wrong with assignment?

fn main() -> int {
  let id6:&&int, id7:int;
  *id6[1] = id7;
  return id9;
}

#Needed to fix non-function type



































#Differences:

struct t {
    a: int
}

fn f(x: int) -> int {
    return 1;
}

fn g(x: s, y: int) -> int {
    return q; // Assuming q is a variable not defined in the provided code
}

fn h() -> _ {
    return;
}

extern e: (int) -> int;

fn main() -> int {
    let x: &q;
    x = new q; // Error: 'q' is not defined
    return x.a; // Error: Dereferencing a pointer to a non-structure type
}



#New allocations
fn somefunction(a: int, b: int) -> int {
    return a + b;
}
struct t {a:int}
fn main() -> int {
    let x:&int, y:int, z:&t;
    z = new &&t;//also try &t and int
}








#Final issues
fn bar1() -> int {
    let id79:&int = 4;
    id79[id79[id77]]();
    return;
}
