Id:
- Valid: Id(x)
- Invalid: Id(2)--works but won't with type checking

Num:
- Valid: Num(3)
- Invalid: Num(3.0), Num(a)-catches a check

Unop:
- Valid: Star Id(x),  Dash Id(x)
- Invalid: Id(x) Dash, Star Num(2), -Struct (all fail)
- Multiple: 
    - Valid: Star Dash Id(x) (works)

Binop
- Valid: Id(x) Dash/Plus Id(y)
- Id(x) Star Id(y)
-  OpenParen Id(x) Plus Id(y) CloseParen Star Id(y)
-Invalid: Id(x) Dash Plus Id(y) - correctly fails

Binop and Unop
- Valid
- Id(x) Dash Star Id(y) - yes
- Id(x) Dash Star Id(y) - yes
- Star OpenParen Dash Id(x) Plus Id(x) OpenBracket Star Id(x) CloseBracket CloseParen OpenBracket Num(2) Dash Id(x) CloseBracket

Access:
- Valid: Id(x) OpenBracket Num(1) CloseBracket
- Invalid: Num(a) no, Id(2) yes
    - Id(x) OpenBracket Id(1) CloseBracket - passes, typez
-Multiple: 
1.  Id(x)   //Works
    OpenBracket
    Num(1)
    CloseBracket
    OpenBracket
    Num(2)
    CloseBracket
    OpenBracket
    Num(3)
    CloseBracket
2. Two Star's infront of 1. works


Several:
x+*y-(z[1]*2); //Success
Id(x)
Plus
Star
Id(y)
Dash
OpenParen
Id(z)
OpenBracket
Num(1)
CloseBracket
Star
Num(2)
CloseParen
Semicolon


Duplicate names:
#1
let x:int, x:int, x:int;
struct y{a:int, a:int}
fn main() -> int {
return 0;
}

This works. So we just store one but it's not an error.

#2: Nil type errors in main and other function
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + nil;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + nil;
return 0;
}


#2: Function calling another function
struct s{a:int, a:int}
extern e:(int, int) -> int;
fn f(fval:int) -> int { 
    let x:int;
    let y:int = 2;
    g(x);
    h(x);
    return 3; 
}
fn g(gval:int) -> _ {
    let a:int = 3 + 2;
    return;
}
let a:int, b:int, c:int;
fn main() -> int {
let x:int;
let y:int = 2;
let z:int = x + y;
return z;
}

#3: Type errors are ordered alphabetically
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y;
    return nil + z[1];
}
fn main() -> int {
return 0;
}

#Which type to return? Not always Any.

struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    return r;
}
fn g(gval:int) -> _ {
    let a:int = 3 + y + z;
    let b:int = z;
    return f();
}
fn main() -> int {
return;
}

//return f() causes an error: in function g: should return nothing but returning int, 
//replacing f() with nil + z[1], or any addition, also gives the int error
//nil gives &_, z gives _. Clearly, for non nil or variable, you should return what it intends to

#4: Deref error returns Any
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn f(fval:int) -> int { 
    let r:int;
    return *r;
}
fn main() -> int {
return;
}

#4: Dereferncing nil works as many times, becuase it becomes any. NOTE, actual grammar must return
struct s{a:int, a:int}
let g:s;
struct t{a:s}
fn e(eval:int) -> int { 
    return eval;
}
fn f(fval:int) -> int { 
    return ******nil;
}
fn main() -> int {
    return;
}


Binop:
#1: left error then right error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + ex;
}

#2 Binop eq/not eq order: left right, both types different
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (ex == ex2);
    return 1;
}

#3: Binop with Any type compares equal correctly (only one error)
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    let ex2:t;
    let result:int = (z == ex2);
    return 1;
}

#ArrayAccess

#1: Don't need to worry about nil, parse error
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int = nil[1]; (also x = nil.x doesn't work)
    return 1;
}

#2: Order, int type first
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int, x:int, y:int, ex:s;
    n = new int;
    x = y[ex];
    return 2;
}

Structs:
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let ex:s;
    return nil + s;
}

#2: Global var as struct
struct s{a:int}
let g:s;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    g = 5;
    return 2;
}

#3: his example:

struct list {
  value: int,
next: &list }
fn main() -> int {
  let n:&list, m:&list, i:int = 3;
  n = new list;
  m = n;
  while i > 0 {
    n.next = new list;
    n.value = i;
    n = n.next;
    i = i - 1;
}
  return aggregate(m);
}
fn aggregate(p: &list) -> int {
  let m:&list, i:int = 0;
  while m != nil {
    i = 10 * i + m.value;
m = m.next; }
return i; }

#4: Struct accesses must be from pointers
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int, st:t;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    z = st.q;
    return 2;
}

#5 Don't need to worry about nillet g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let x:int;
    x = nil.x
    return 1;
}

#6 Shows the types of local structs and outer structs. If you print all structs and locals after making maps
struct t{a:int}
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn main() -> int {
    let tex:&t, x:int;
    return;
}
Structs
t:
Key:[a] Value:[int]

Locals
f:
Key:[x] Value:[int]
Key:[tex] Value:[&struct_t]
Key:[fval] Value:[int]
Key:[f] Value:[&(int) -> int]


#7 Nonexistent struct type:

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:&q;
    x = new q;
    return x.a;
}

#9 Incorrect type
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:s;
    return x.a;
}

#10 Any type with more than one preceding & is incorrect
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return q;
}
fn h() -> _ {
return;
}
extern e:(int) -> int;
fn main() -> int {
    let x:&&t;
    x = new q;
    return x.a;
}

Functions:
#1: Can call main (with error) and still get parameter number comparisons. Replacing with main() works. Main calls can't be external. Main overwrites.
struct t{a:int}
extern main:(int, int) -> int;
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> _ {
    let x:int;
    x = main(2, 3);
}
fn main() -> int {
    let x:int;
    x = main(2, 3);
    g();
    return *x + -nil;
}

#2 nil() is a parse error

#3 can't have empty arguments f(2,)

#4 Example using Functions: can't have function or struct types as argument (CAN HAVE FUNCTION POINTERS) Error that ext has struct or function type
struct t{a:int}
extern e:(int) -> int;
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn g(r:int) -> int {
    return 3;
}
fn main() -> int {
    let x:int;
    x = f(2, e, g);
    return 1;
}

#5: CAN return an extern
struct t{a:int}
extern e:(int) -> int;
fn f() -> _ {}
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn temp(t:int) -> int {
    return 1;
}
fn g(r:int) -> (int)->int {
    return e;
}
fn main() -> int {
    let x:int;
    return 1;
}

#6 Functions take precedence over duplicate extern names

struct t{a:int}

fn e(x:int) -> int {
    return 1;
}
extern e:(int) -> int;
fn f() -> _ {}
fn f(fval:int, ext:(int)->int, in:&(int)->int) -> int {
    let x:int = ext(2);
    return 2;
}
fn temp(t:int) -> int {
    return 1;
}
fn g(r:int) -> (int)->int {
    return e;
}
fn main() -> int {
    let x:int;
    return 1;
}

#7 Calling main gives callee with type Id(main)
struct t{a:int}

fn e(x:int) -> int {
    return 1;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int = main();
    return 1;
}

#8 Number of parameters don't match and parameters types. This way, both a number error and type mismatching. If you swap x and y then parameters do match but not equal number.
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int;
    x = g(2);
    return 1;
}

#9 Error messages for all incorrect types
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int, y:t;
    x = g(2, y, 3);
    return 1;
}

#10 Confirming that expression type must equal parameter type
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:int) -> int {
    return 2;
}
extern e:(int) -> int;
fn main() -> int {
    let x:int, y:t, z:int;
    x = g(x+z);
    return 1;
}

#11 Last main matters
struct t{a:int}
extern main:(int, int) -> int;
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> _ {
    let x:int;
    return;
}
fn main() -> int {
    let x:int;
    return main(2, 3);
}
fn main(x:int) -> _ {
    return;
}

#12 undefined still gives main error
struct t{a:int}
fn f(fval:int) -> int {
    let tex:&t, x:int;
    return;
}
fn g() -> int {
    let x:int;
    return main(1, 2);
}


#13 Function pointers
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int, t) -> _;
fn main() -> int {
    let x:int, y:s, z:&(int)->int;
    *z(1);
    return;
}

#14 Main doesn't propagate

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    return 2;
}
extern e:(int, t) -> _;
fn main() -> int {
    let x:int, y:s, z:main;
    z(1);
    return;
}


#15 Main defined as extern doesn't count as extern, as intern
struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let x:int, y:s;
    main(1);
    k(1);
    return;
}

#16 Function pointer need to handle

struct t{a:int}

fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let x:int, y:()->_;
    y = 2;
    y(1);
    return;
}

#17 Global function pointers also work, but overriden by things like locals (if you replace z with x in h())
let x:&(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(x:s, y:int) -> int {
    main(1);
    return 2;
}
extern main:(int) -> _;
extern k:() -> _;
fn h() -> int {
    let z:int, y:()->_;
    y = 2;
    x(1);
    return;
}

#18 Parameters still need to match for extern
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int) -> int {
    main(1);
    return 2;
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return z.b;
}

#19 Good example, main a parameter
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int, z:()->_) -> int {
    main(1);
    z(1);
    return 2;
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return z.b;
}

#20: Huge example. Works. Also works if f replaced for f() as argument
let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(main:int, y:int, z:(int)->int) -> int {
    main(1);
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return g(1, 2, f);
}

#21 Testing local variable overriding non main function (works, also works with replace f in g() param for x or e)

let x:(int)->int;
struct t{a:int}
fn f(x:int) -> int {
    return 1;
}
fn g(f:int, y:int, z:(int)->int) -> int {
    f();
    return z(1);
}
extern e:(int) -> _;
extern k:() -> _;
fn h() -> int {
    x();
    return g(1, 2, f(1));
}


Miscellaneous:
#1: Main has to have local variable declaraions at top
struct s{a:int}
let g:int;
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let n:&int;
    let x:int = 2;
    n = new int;
    let x:int;
    return 2;
}

#2: Errors sorted by alphabetical value for key and error list!
struct t{a:int}
fn f(fval:int) -> int { 
    return;
}
fn main() -> int {
    let tex:&t, qex:&q, x:int, y:int, z:int;
    tex = new t;
    qex = new q;
    
    y = qex.a;
    x = tex.c;
    x = tex.b;
    z = x.a;
    return 2;
}
